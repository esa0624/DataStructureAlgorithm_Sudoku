from copy import deepcopy
import numpy as np
import random


# program utilizes a Depth First Search for solving sudoku solution.
# Converts a text file containing one sudoku problem into a list of possible solutions
    # now it can also accept the sudoku in dict form generated by Tori's codes
# for each possibility of each square a new "branch" is explored completely until it leads to a solution or not.


# begins the recursive function
def sudoku_solver_help(sudoku_dic):
    grid = load_sudoku_from_dict(sudoku_dic)
    solution = []
    sudoku_solver(grid, solution)
    return return_solns(solution[0])


def sudoku_check_unique(sudoku_dic):
    grid = load_sudoku_from_dict(sudoku_dic)
    solutions = []
    sudoku_solver(grid, solutions, 2)
    return len(solutions) == 1

# recursive sudoku solver function
def sudoku_solver(grid, solutions, ans_count = 1):
    for i in range(len(grid)):
        for j in range(len(grid)):
            if len(grid[i, j]) == 1:
                valid_grid(grid, i, j, grid[i, j][0])
    solved_board = True
    # checks if the board is unsolvable with no avaliable solutions for a grid
    for i in range(len(grid)):
        for j in range(len(grid)):
            if len(grid[i, j]) == 0:
                # print('wrong!')
                return False
            elif len(grid[i, j]) != 1:
                solved_board = False
    # if enough solution is found then return Trur, 
    # otherwise return False to keep finding other solution
    if solved_board:
        solutions.append(grid)
        return len(solutions) == ans_count
    else:
        # find the first grid that haven't been determined
        for i in range(len(grid)):
            for j in range(len(grid)):
                # try every possible numbers
                if len(grid[i, j]) > 1:
                    for val in grid[i, j]:
                        # copy current board for further trials
                        new_board = deepcopy(grid)
                        valid_grid(new_board, i, j, val)
                        # when enough solutions are found stop the recursion
                        if sudoku_solver(new_board, solutions, ans_count=ans_count):
                            return True
                    # if all possible numbers in this grid fail, directly stop trying and return False
                    return False


# check if current value being put into the grid is valid 
    # actually do not need to check this â†‘ since you only pick the 
    # number from possible number in the grid
# checks it against row, column and square
# removes the value from list of possible values for each item in the grid
def valid_grid(grid, x, y, num):
    # check row
    for i in range(9):
        if num in grid[x, i]:
            grid[x, i].remove(num)
    # check col
    for i in range(9):
        if num in grid[i, y]:
            grid[i, y].remove(num)
    # check square
    square_start_col = (x // 3) * 3
    square_start_row = (y // 3) * 3
    for j in range(square_start_col, square_start_col + 3):
        for k in range(square_start_row, square_start_row + 3):
            if (num in grid[j, k]):
                grid[j, k].remove(num)
    grid[x, y] = [num]

# convert the solution to np array
def return_solns(grid):
    sudoku = np.zeros((9, 9), int)
    for r in range(len(grid)):
        for c in range(len(grid)):
            sudoku[r, c] = grid[r, c][0]
    return sudoku

# convert the sudoku from dict form to the np array of list of possible numbers in each grid
def load_sudoku_from_dict(dic: dict):
    grid = np.empty((9, 9), list)
    for r in range(9):
        for c in range(9):
            if (r, c) in dic.keys():
                grid[r, c] = [dic[(r, c)]]
            else:
                grid[r, c] = list(range(1, 10))
    return grid


# load the file of sudoku start
def load_sudoku_from_file(path):
    # load a single sudoku file from a file name
    # sudoku_file_example is how a problem must be formatted to be solved like this
    # Assuming a standard 9x9 Sudoku puzzle
        # I changed ths python list here to np array since 
        # the size of the board do not change during the whole program
        # and np array can make things fast (maybe?)
    grid = np.empty((9, 9), list) 
    with open(path, 'r') as file:
        for r in range(9):
            line = file.readline().strip()  # Remove newline characters
            for c in range(len(line)):
                if line[c] == '0':
                    # Cell is empty, add all possibilities
                    grid[r, c] = list(range(1, 10))
                else:
                    # Cell has a fixed number, add it as the only possibility
                    grid[r, c] = [int(line[c])]
    return grid


# Remove numbers to generate the puzzle
def generate_puzzle(grid, difficulty=0.05):
    """Generate a Sudoku puzzle with specified difficulty.
    Args:
        difficulty (float): The difficulty level of the puzzle (a fraction between 0 and 1).
    Returns:
        np array: The generated Sudoku board.
    """
    return remove_numbers(np.copy(grid), difficulty)

def remove_numbers(grid, difficulty):
    """Remove numbers from the Sudoku board to create a puzzle.
    Args:
        grid (np array): The Sudoku board.
        difficulty (float): The difficulty level of the puzzle (a fraction between 0 and 1).
    Returns:
        np array: The Sudoku puzzle with removed numbers.
    """
    # Calculate the number of cells to remove based on the difficulty level
    total_cells = 81
    cells_to_remove = int(total_cells * (1 - difficulty))

    # Create a list of all cell coordinates
    all_cells = [(i, j) for i in range(9) for j in range(9)]
    random.shuffle(all_cells)

    # Copy the Sudoku board to prevent modification of the original board
    puzzle = np.copy(grid)
    for i in range(cells_to_remove):
        row, col = all_cells[i]
        backup = puzzle[row, col]
        puzzle[row, col] = 0

        # Check if the puzzle still has a unique solution
        if not has_unique_solution(puzzle):
            puzzle[row, col] = backup
    return puzzle

def has_unique_solution(grid):
    """Check if the Sudoku puzzle has a unique solution.
    Args:
        grid (np array): The Sudoku board to be checked.
    Returns:
        bool: True if the Sudoku puzzle has a unique solution, False otherwise.
    """
    # Create a copy of the board to prevent modification of the original board
    grid_copy = np.copy(grid)
    empty_cells = [(i, j) for i in range(9) for j in range(9) if grid_copy[i, j] == 0]
    return find_solution_count(grid_copy, empty_cells) == 1

def find_solution_count(grid, empty_cells):
    """Find the number of solutions for the Sudoku puzzle.
    Args:
        grid (np array): The Sudoku board to be solved.
        empty_cells (list of tuples): List of empty cell coordinates.
    Returns:
        int: The number of solutions for the Sudoku puzzle.
    """
    if not empty_cells:
        return 1
    row, col = empty_cells.pop()
    possible_nums = list(range(1, 10))
    random.shuffle(possible_nums)
    solution_count = 0
    for num in possible_nums:
        if is_valid(grid, row, col, num):
            grid[row, col] = num
            solution_count += find_solution_count(grid, empty_cells)
            grid[row, col] = 0
            # If more than one solution is found, stop searching
            if solution_count > 1:
                break
    empty_cells.append((row, col))
    return solution_count

def is_valid(grid, row, col, num):
    """Check if the given number is valid to place at the given position (row, col) on the Sudoku board.
    Args:
        grid (np array): The Sudoku board.
        row (int): The row index.
        col (int): The column index.
        num (int): The number to be placed.
    Returns:
        bool: True if the number is valid to place, False otherwise.
    """
    # Check if the number is already in the current row
    if num in grid[row]:
        return False
    # Check if the number is already in the current column
    if num in grid[:, col]:
        return False
    # Check if the number is already in the current 3x3 subgrid
    start_row, start_col = 3 * (row // 3), 3 * (col // 3)
    if np.any(grid[start_row:start_row + 3, start_col:start_col + 3] == num):
        return False
    return True

def print_grid(grid):
    """Print the Sudoku.
    Args:
        grid: The Sudoku board to be printed.
    """
    for row in grid:
        print(row)


# sudoku_dic = Sudoku_matrix_9x9.sudoku_init(9)
# sudoku = sudoku_solver_help(sudoku_dic)
# print("\nBoard: ")
# print_grid(sudoku)
#
# puzzle = generate_puzzle(sudoku, 0.1)
# print("\nPuzzle: ")
# print_grid(puzzle)
